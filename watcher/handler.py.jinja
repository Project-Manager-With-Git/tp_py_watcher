import os
import time
from hashlib import md5
from watchdog.observers import Observer
from watchdog.observers.polling import PollingObserver
from watchdog.events import FileSystemEventHandler, DirModifiedEvent, FileModifiedEvent
from pyloggerhelper import log
from typing import Dict, Union


class EventHanddler(FileSystemEventHandler):
    """事件处理回调.

    需要实现的部分
    """
    latest: Dict[str, bytes]

    def __init__(self, ) -> None:
        self.latest = {}

    def on_modified(self, event: Union[DirModifiedEvent, FileModifiedEvent]) -> None:
        log.info("handdler get event", get_event=event)
        if isinstance(event, FileModifiedEvent):
            with open(event.src_path) as f:
                content = f.read()
            if content:
                m = md5()
                m.update(content.encode("utf-8"))
                nowmd5 = m.digest()
                lastmd5 = self.latest.get(event.src_path)
                if lastmd5:
                    if lastmd5 != nowmd5:
                        self.latest[event.src_path] = nowmd5
                        log.info("get file modified", p=event.src_path, content=content)
                else:
                    self.latest[event.src_path] = nowmd5
                    log.info("get file modified", p=event.src_path, content=content)




def watch(watch_path: str, *, in_docker: bool = False) -> None:
    """监控文件系统的函数.

    可以直接作为监控程序使用,注意需要先初始化log.
    
    """
    observer = Observer()
    handler = EventHanddler()
    observer.schedule(handler, watch_path, recursive=True)
    log.info('FSEvent Watching, Press Ctrl+{0} to exit'.format('Break' if os.name == 'nt' else 'C'))
    observer.start()
    try:
        while True:
            time.sleep(1)
    except (KeyboardInterrupt, SystemExit):
        log.info('crontab task stoped')
    except Exception as e:
        log.error("crontab task get error", err=type(e), err_msg=str(e), exc_info=True, stack_info=True)
    finally:
        observer.stop()
        observer.join()