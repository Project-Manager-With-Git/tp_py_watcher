import os
import time
from hashlib import md5
from watchdog.observers import Observer
from watchdog.observers.polling import PollingObserver
from watchdog.events import FileSystemEventHandler, DirModifiedEvent, FileModifiedEvent
from pyloggerhelper import log
from typing import Dict, Union


class EventHanddler(FileSystemEventHandler):
    """事件处理回调.

    需要实现的部分.
    可以重载如下方法:
    + `on_any_event(event: FileSystemEvent)->None`,只要有事件就触发
    + `on_closed(event:FileClosedEvent)->None`,打开的文件被关闭就会触发
    + `on_created(event: DirCreatedEvent | FileCreatedEvent)->None`文件或文件夹被创建就会触发
    + `on_deleted(event: DirDeletedEvent | FileDeletedEvent)->None`文件或文件夹被删除就会触发
    + `on_modified(event: DirModifiedEvent | FileModifiedEvent)->None`文件或文件夹被修改就会触发
    + `on_moved(event: DirMovedEvent | FileMovedEvent)->None`文件或文件夹被移动就会触发
    """
    latest: Dict[str, bytes]

    def __init__(self, ) -> None:
        self.latest = {}

    def on_modified(self, event: Union[DirModifiedEvent, FileModifiedEvent]) -> None:
        log.info("handdler get event", get_event=event)
        if isinstance(event, FileModifiedEvent):
            with open(event.src_path) as f:
                content = f.read()
            if content:
                m = md5()
                m.update(content.encode("utf-8"))
                nowmd5 = m.digest()
                lastmd5 = self.latest.get(event.src_path)
                if lastmd5:
                    if lastmd5 != nowmd5:
                        self.latest[event.src_path] = nowmd5
                        log.info("get file modified", p=event.src_path, content=content)
                else:
                    self.latest[event.src_path] = nowmd5
                    log.info("get file modified", p=event.src_path, content=content)




def watch(watch_path: str, *, in_docker: bool = False) -> None:
    """监控文件系统的函数.

    可以直接作为监控程序使用,注意需要先初始化log.
    
    """
    observer = Observer()
    handler = EventHanddler()
    observer.schedule(handler, watch_path, recursive=True)
    log.info('FSEvent Watching, Press Ctrl+{0} to exit'.format('Break' if os.name == 'nt' else 'C'))
    observer.start()
    try:
        while True:
            time.sleep(1)
    except (KeyboardInterrupt, SystemExit):
        log.info('crontab task stoped')
    except Exception as e:
        log.error("crontab task get error", err=type(e), err_msg=str(e), exc_info=True, stack_info=True)
    finally:
        observer.stop()
        observer.join()